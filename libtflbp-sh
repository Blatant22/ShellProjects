#!/bin/sh

#----------------------------------------------------------------------------------
# Project Name      - Extra/libtflbp-sh (Terminal for Life Bourne POSIX)
# Started On        - Mon  2 Dec 15:32:30 GMT 2019
# Last Change       - Thu  5 Dec 20:20:07 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# POSIX-adhering function library for extra, portable Bourne Shell functionality.
#
# NOTE: POSIX compliance has largely been determined through the guidance of YASH.
#----------------------------------------------------------------------------------

tflbpsh(){ #: Basic core library features. (see: '--help|-h|-?')
	CurVer='2019-12-02'
	Progrm=${0##*/}

	printf "POSIX Bourne library '%s' is version '%s'.\n" "$CurVer" "$Progrm"

	unset CurVer Progrm
}

Err(){ #: Exit status $1 (0 by default) with error message $2.
	printf "ERROR: %s\n" "$2" 1>&2
	[ $1 -gt 0 ] && exit $1
}

SplitStr(){ #: Split string $2 by delimiter $1.
	local IFS=$1
	set -- $2
	printf "%s\n" "$@"

	unset IFS
}

CutStr(){ # Cut string $3 by $1 delimiter, displaying $2 field(s).
	IFS=$1; shift
	Fields=$1; shift

	set -- $1

	for CutField in $Fields; do
		Count=0
		for CurField in "$@"; do
			Count=$((Count + 1))
			if [ $Count -eq $CutField ]; then
				printf "%s%s" "$CurField" "$IFS"
				break 1
			fi
		done
	done

	unset IFS Field CurField Count CutField
}


LCount(){ #: Fetch the total number of lines. (also accepts STDIN)
	Count=0
	if [ $# -eq 0 ]; then
		while read -r CurLine; do
			Count=$((Count + 1))
		done < /dev/stdin

		printf "%d\n" $Count

	else
		printf "%s\n" "$@" | while read -r CurLine; do
			Count=$((Count + 1))
		done

		printf "%d\n" $#
	fi

	unset Count CurLine
}

WCount(){ #: Fetch the total number of words. (also accepts STDIN)
	if [ $# -eq 0 ]; then
		read Input < /dev/stdin
		set -- $Input
		printf "%d\n" $#

		unset Input
	else
		set -- $*
		printf "%d\n" $#
	fi
}

GetInsPkgs(){ #: List, from `status` file $1, all installed (`ii`) Debian packages.
	while read Key Value _; do
		[ -z "$Key" ] && continue

		case $Key in
			Package:)
				Package=$Value ;;
			Status:)
				[ "$Value $_" = 'install ok installed' ] || continue ;;
			*)
				continue ;;
		esac

		if ! [ "$Package" = "$OldPackage" ]; then
			List=" $List $Package "
		fi

		OldPackage=$Package
	done < "${1:-/var/lib/dpkg/status}"

	printf "%s\n" $List

	unset StatusFile Package OldPackage List Key Value _
}

YNInput(){ #: An easy-to-script prompt for the user, asking yes or no.
	printf "$1 [Y/N] "
	read Answer
	printf "\n"

	case $Answer in
		[Yy]|[Yy][Ee][Ss])
			return 0 ;;
		[Nn]|[Nn][Oo])
			return 1 ;;
		''|*)
			Err 1 'Invalid response -- quitting.' ;;
	esac

	unset Answer
}

ChkDep(){ #: Presentable check of PATH directories for dependency $@.
	DepCount=0
	for CurDep in "$@"; do
		if command -v "$CurDep" 1> /dev/null 2>&1; then
			DepCount=$((DepCount + 1))
		else
			Err 0 "Dependency '$CurDep' not met."
		fi
	done

	[ $DepCount -eq $# ] || exit 1
}

BaseName(){ #: Output the base name (like `basename`) of $@.
	for CurFile in "$@"; do
		[ -f "$CurFile" ] || return 1
		printf "%s\n" "${CurFile##*/}"
	done
}

DirName(){ #: Output the directory name (like `dirname`) of $@.
	for CurDir in "$@"; do
		[ -d "$CurDir" ] || return 1
		printf "%s\n" "${CurDir%/*}"
	done
}
