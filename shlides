#!/usr/bin/env bash

#----------------------------------------------------------------------------------
# Project Name      - Extra/shlides
# Started On        - Sun 17 Nov 16:27:40 GMT 2019
# Last Change       - Thu 21 Nov 00:24:04 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

#TODO - Catch executing shlides on a non-shlides file.

_VERSION_="2019-11-21"
_PROJECT_="${0##*/}"

FAIL(){
	printf "[L%0.4d] ERROR: %s\n" "$2" "$3" 1>&2
	[ $1 -eq 1 ] && exit 1
}

BASHDEBUG='false'

DEBUG(){
	if [ "$BASHDEBUG" == 'true' ]; then
		set -x
	elif [ "$DEBUGME" == "true" ]; then
		if [ $# -eq 3 ]; then
			printf "[L%0.4d] DEBUG(\$%s): '%s'\n" "$1" "$2" "$3"
		elif [ $# -eq 2 ]; then
			printf "[L%0.4d] DEBUG: %s\n" "$1" "$2"
		else
			FAIL 1 "$LINENO" "Invalid 'DEBUG()' argument(s)."
		fi
	fi
}

DOM="https://github.com"

USAGE(){
	while read -r; do
		printf "%s\n" "$REPLY"
	done <<-EOF
		            ${_PROJECT_^^} ($_VERSION_)
		            Written by terminalforlife (terminalforlife@yahoo.com)

		            Present a project on your terminal via formatted slides.

		SYNTAX:     $_PROJECT_ [OPTS] FILE

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --update|-U             - Check for updates to $_PROJECT_.
		            --debug|-D              - Enables debugging information.
		            --interactive|-i        - Wait for the user to press a key.
		            --tildes|-T             - Use the EOF tildes like in vim.
		            --escape|-E             - Allow terminal escape sequences.
		            --no-header             - Omit the header from each slide.
		            --no-footer             - Omit the footer from each slide.
		            --effect|-e             - Apply a downward sweeping effect.
		            --borders|-b            - Pretty borders around the header.
		            --wait|-w INT           - Wait INT second(s) between slides.
		            --skip-start|-s         - Skip the message at project start.

		SITE:       $DOM/terminalforlife/Extra
	EOF

#		            --bstyle|-B STYLE       - Replace the default border style.
}

WaitTime=0.5
EffectDelay=0.03

while [ "$1" ]; do
	case $1 in
		--help|-h|-\?)
			USAGE; exit 0 ;;
		--version|-v)
			printf "%s\n" "$_VERSION_"; exit 0 ;;
		--update|-U)
			UPDATE='true'

			DEBUG "$LINENO" "UPDATE" "$UPDATE" ;;
		--debug|-D)
			DEBUGME='true'

			DEBUG "$LINENO" "DEBUGME" "$DEBUGME" ;;
		--interactive|-i)
			INTERACTIVE='true'

			DEBUG "$LINENO" "INTERACTIVE" "$INTERACTIVE" ;;
		--tildes|-T)
			USETILDES='true'

			DEBUG "$LINENO" "USETILDES" "$USETILDES" ;;
		--escape|-E)
			ESCAPE='true'

			DEBUG "$LINENO" "ESCAPE" "$ESCAPE" ;;
		--no-header)
			NOHEADER='true'

			DEBUG "$LINENO" "NOHEADER" "$NOHEADER" ;;
		--no-footer)
			NOFOOTER='true'

			DEBUG "$LINENO" "NOFOOTER" "$NOFOOTER" ;;
		--effect|-e)
			EFFECT='true'

			DEBUG "$LINENO" "EFFECT" "$EFFECT" ;;
		--borders|-b)
			BORDERS='true'

			DEBUG "$LINENO" "BORDERS" "$BORDERS" ;;
		--wait|-w)
			shift

			if [[ $1 =~ ^[0-9]+$ ]]; then
				WaitTime=$1
				WAIT='true'

				DEBUG "$LINENO" "WaitTime" "$WaitTime"
				DEBUG "$LINENO" "WAIT" "$WAIT"
			else
				FAIL 1 "$LINENO" "Specified wait time is invalid."
			fi ;;
		--skip-start|-s)
			SKIPSTART='true'

			DEBUG "$LINENO" "SKIPSTART" "$SKIPSTART" ;;
		-*)
			DEBUG "$LINENO" "1" "$1"

			FAIL 1 "$LINENO" "Incorrect argument(s) specified." ;;
		*)
			DEBUG "$LINENO" "1" "$1"
			DEBUG "$LINENO" "Breaking from parameter while loop."

			break ;;
	esac

	DEBUG "$LINENO" "*" "$*"
	DEBUG "$LINENO" "Shifting positional parameters."

	shift
done

if [ "$WAIT" == 'true' -a "$INTERACTIVE" == 'true' ]; then
	FAIL 1 "$LINENO" "Either '--wait|-w' or '--interactive|-i', not both."
elif [ "$BORDERS" == 'true' ]; then
	if [ "$NOHEADER" == 'true' ]; then
		FAIL 1 "$LINENO" "Option '--borders|-b' used but header disabled."
	elif [ "$NOFOOTER" == 'true' ]; then
		FAIL 1 "$LINENO" "Option '--borders|-b' used but footer disabled."
	fi
fi

DEBUG "$LINENO" "Checking for 'tput' PATH executable."

if ! type -fP tput > /dev/null 2>&1; then
	FAIL 0 "$LINENO" "Dependency 'tput' not met."
fi

if [ "$UPDATE" == "true" ]; then
	DEBUG "$LINENO" "Beginning procedure to check for an update."

	if ! type -fP wget > /dev/null 2>&1; then
		FAIL 1 "$LINENO" "Dependency 'wget' not met."
	fi

	VERSION_URL="$DOM/terminalforlife/Extra/raw/master/versions"
	while IFS='=' read -a LINE; do
		if  [ "${LINE[0]}" == "$_PROJECT_" ]; then
			LATEST="${LINE[1]}"
			DEBUG "$LINENO" "LATEST" "$LATEST"

			if [[ "${LATEST//-}" =~ ^[0-9]{8}$ ]]; then
				DEBUG "$LINENO" "Self version detection successful."

				if [ ${LATEST//-} -gt ${_VERSION_//-} ]; then
					while read -r; do
						printf "%s\n" "$REPLY"
					done <<-EOF
						New version available:    $LATEST
						Current version:          $_VERSION_
					EOF
				fi
			else
				FAIL 1 "$LINENO" "Failed to check for available updates."
			fi
		fi
	done <<< "$(wget -q "$VERSION_URL" -O -)"

	exit 0
fi

DEBUG "$LINENO" "1" "$1"

if [ -z "$1" ]; then
	FAIL 1 "$LINENO" "A project file wasn't provided."
elif [ -f "$1" ] && [ -r "$1" ]; then
	ProjectFile=$1

	DEBUG "$LINENO" "ProjectFile" "$ProjectFile"
	DEBUG "$LINENO" "Shifting positional parameters."

	shift

	if [ $# -gt 0 ]; then
		FAIL 1 "$LINENO" "Only one project may run at a time."
	fi
elif [[ "$1" ]]; then
	FAIL 1 "$LINENO" "A project file wasn't provided."
else
	FAIL 1 "$LINENO" "Project file missing or unreadable."
fi

RED=`tput setaf 1`; BLUE=`tput setaf 4`; GREEN=`tput setaf 2`
BOLD=`tput bold` WHITE=`tput setaf 7`; YELLOW=`tput setaf 3`
GREY=`tput setaf 0` NORM=`tput cnorm`

PAKTC(){
	read -sn 1
	printf "\n"
}

Cols=${COLUMNS:-`tput cols`}
Lines=${LINES:-`tput lines`}

DEBUG "$LINENO" "COLUMNS" "$COLUMNS"
DEBUG "$LINENO" "LINES" "$LINES"
DEBUG "$LINENO" "Cols" "$Cols"
DEBUG "$LINENO" "Lines" "$Lines"

# Ensure column and line counts are updated, even after window resizing.
trap 'Cols=${COLUMNS:-`tput cols`}; Lines=${LINES:-`tput lines`}' WINCH

# Function for handling the correct number of line characters.
UnderLine(){
	DEBUG "$LINENO" "Function 'UnderLine()' called."
	DEBUG "$LINENO" "1" "$1"
	DEBUG "$LINENO" "2" "$2"
	DEBUG "$LINENO" "3" "$3"

	for ((I=1; I<Cols; I++)); {
		if [ $I -eq 1 ]; then
			printf "%s" ${1:0:1}
		elif [ $I -eq $((Cols - 1)) ]; then
			printf "%s" ${3:0:1}
		else
			printf "%s" ${2:0:1}
		fi
	}
}

Header(){
	printf "\n" # <-- Fixes weird missing line 1 bug in header.

	ColsSubstr=${Cols:$[${#Cols} - 1]:1}
	[[ $ColsSubstr == [13579] ]] && let Cols++

	DEBUG "$LINENO" "Function 'Header()' called."
	DEBUG "$LINENO" "1" "$1"
	DEBUG "$LINENO" "2" "$2"
	DEBUG "$LINENO" "3" "$3"

	Title="'${2//_/ }'"

	if [ -n "${Title//\'}" ]; then
		TitleHalf=$[${#Title} / 2]
		TitleEndAlign=$[(Cols - ${#Title}) + 1]
		TitlePush=$TitleEndAlign

		DEBUG "$LINENO" "Title" "$Title"
		DEBUG "$LINENO" "TitleHalf" "$TitleHalf"
		DEBUG "$LINENO" "TitleEndAlign" "$TitleEndAlign"
		DEBUG "$LINENO" "TitlePush" "$TitlePush"

		if [ "$BORDERS" == 'true' ]; then
			UnderLine '╭' '─' '╮'

			printf "%s%*s%*s\n" '│' $[((Cols / 2) + TitleHalf) - 2]\
				"$Title" $[((Cols / 2) - TitleHalf) + 2] '│'

			UnderLine '╰' '─' '╯'
		else
			printf "%*s" $[((Cols / 2) + TitleHalf) - 2] "$Title"
		fi
	else
		tput clear
		FAIL 1 "$LINENO" "Slide $SlideNumber has no header title."
	fi
}

CursorDown(){
	[ "$DEBUGME" == 'true' ] || tput cup ${1:-$Lines} ${2:-$Cols}
}

Footer(){
	CursorDown $[Lines - 3] $Cols
	printf " " # <-- Seems to correct mis-algnment.

	ColsSubstr=${Cols:$[${#Cols} - 1]:1}
	[[ $ColsSubstr == [13579] ]] && let Cols++

	DEBUG "$LINENO" "Function 'Footer()' called."
	DEBUG "$LINENO" "1" "$1"
	DEBUG "$LINENO" "2" "$2"
	DEBUG "$LINENO" "3" "$3"

	if [ "$BORDERS" == 'true' ]; then
		UnderLine '╭' '─' '╮'

		# Combined, the Left and Right variables can handle another ~25 spaces, if
		# the terminal session's columns available is at 95.
		FooterTextLeft="FILE: '${ProjectFile##*/}' ⟐ SLIDE: $SlideNumber "
		FooterTextRight="BODY: L$[Cols - 2] C$[Lines - 8] ⟐ HOST: $HOSTNAME"

		if [ $[${#FooterTextLeft} + ${#FooterTextRight}] -lt $[Cols - 10] ]; then
			tput cup $Lines
			printf "│ $FooterTextLeft"
			tput cup $Lines $[(Cols - ${#FooterTextRight}) - 3]
			printf "$FooterTextRight │"
		else
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 "$LINENO" "Insufficent space for the footer."
		fi

		UnderLine '╰' '─' '╯' || printf "\n"
	else
		FooterTextLeft="FILE: '${ProjectFile##*/}' ⟐ SLIDE: $SlideNumber "
		FooterTextRight="BODY: L$[Cols - 2] C$[Lines - 8] ⟐ HOST: $HOSTNAME"

		if [ $[${#FooterTextLeft} + ${#FooterTextRight}] -lt $[Cols - 10] ]; then
			tput cup $Lines
			printf "  $FooterTextLeft"
			tput cup $Lines $[(Cols - ${#FooterTextRight}) - 3]
			printf "$FooterTextRight  "
		else
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 "$LINENO" "Insufficent space for the footer."
		fi
	fi
}

[ "$DEBUGME" == 'true' ] || tput clear

# Short, optional introduction of shlides.
if ! [ "$SKIPSTART" == 'true' ]; then
	tput cup $[(Lines / 2) - 1]
	Text="Presentation created with shlides, version $_VERSION_."
	printf "${RED}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"

	tput cup $[(Lines / 2) - 0]
	Text="Written by 'terminalforlife', also known as 'Learn Linux'."
	printf "${YELLOW}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"

	tput cup $[(Lines / 2) + 1]
	Text="Licensed under the 'GNU General Public License v3.0'."
	printf "${YELLOW}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"

	tput cup $[(Lines / 2) + 3]
	Text="https://github.com/terminalforlife"
	printf "${WHITE}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"
fi

# Output and parse lines of body.
FirstLineFromBuffArr='false'
readarray BuffArr < "$ProjectFile"
for CurLine in "${BuffArr[@]%$'\n'}"; {
	if [ "$DoSkipSlide" == 'true' ] || [[ $CurLine == \#\ * ]]; then
		continue
	elif [[ $CurLine =~ ^###\  ]]; then
		if [ "$FirstLineFromBuffArr" == 'true' ]; then
			FirstLineFromBuffArr='true'
		else
			CursorDown
			unset FirstLineFromBuffArr
		fi

		if [ -n "$OldLine" ]; then
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 "$LINENO" "Line '$BodyLines' is non-empty."
		elif [ ${BodyLines:-0} -gt $[Lines - 8] ]; then
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 "$LINENO" "Line overflow ($BodyLines/$[Lines - 8]) in the body of slide $SlideNumber."
		fi

		if [ "$INTERACTIVE" == 'true' ]; then
	  		PAKTC
		else
			sleep ${WaitTime}s
		fi

		[ "$DEBUGME" == 'true' ] || tput clear

		MainLines=1
		BodyLines=0
	fi

	DEBUG "$LINENO" "MainLines" "$MainLines"

	#printf "M%d:" "$MainLines"
	if [ $MainLines -eq 1 ]; then
		# Gather header commands (key=value), and catch errors.
		FieldCount=0
		for Field in $CurLine; {
			let FieldCount++

			DEBUG "$LINENO" "Field" "$Field"

			if [ ! "$HeaderPrefixFound" == 'true' -a "$Field" == '###' ]; then
				HeaderPrefixFound='true'
				continue
			elif [ "$HeaderPrefixFound" == 'true' -a "$Field" == '###' ]; then
				[ "$DEBUGME" == 'true' ] || tput clear
				FAIL 1 "$LINENO" "Only one header prefix is required."
			else
				unset HeaderPrefixFound
			fi

			if [[ $Field == *=* ]]; then
				DEBUG "$LINENO" "Valid field found."

				IFS='=' read -a FieldArray <<< "$Field"

				DEBUG "$LINENO" "FieldArray" "$FieldArray"
				if [ "${FieldArray[0]}" == "SLIDE" ]; then
					SlideNumber=${FieldArray[1]}
					DEBUG "$LINENO" "SlideNumber" "$SlideNumber"
				elif [ "${FieldArray[0]}" == "TITLE" ]; then
					SlideTitle=${FieldArray[1]//\"}
					DEBUG "$LINENO" "SlideTitle" "$SlideTitle"
				else
					[ "$DEBUGME" == 'true' ] || tput clear
					FAIL 1 "$LINENO" "Invalid header command at field $FieldCount."
				fi
			else
				[ "$DEBUGME" == 'true' ] || tput clear
				FAIL 1 "$LINENO" "Invalid header field at position $FieldCount."
			fi
		}

		# Actually display the header, based on `*.shl` header commands.
		if [ "$NOHEADER" == 'true' ]; then
			# If disabled, just ensure a blank line for tidiness.
			printf "\n"
		else
			Header $SlideNumber "$SlideTitle"
		fi

		[ "$NOFOOTER" == 'true' ] || Footer
		CursorDown 4 0
	elif [ $MainLines -eq 2 ]; then
		if [ -n "$CurLine" ]; then
			DEBUG "$LINENO" "CurLine" "$CurLine"

			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 "$LINENO" "Line 2 is non-empty."
		fi
	elif [ $MainLines -gt 2 ]; then
		# Display the body of the current slide.
		if ! [ ${#CurLine} -gt $[Cols - 5] ]; then
			[ "$EFFECT" == 'true' ] && sleep $EffectDelay

			CurLineNoTrail=${CurLine%%[[:space:]]}
			CurLineHalf=$[${#CurLine} / 2]
			CurLineNoSpace=${CurLine//[[:space:]]/}
			if [ "${CurLineNoSpace:0:3}" == '<C>' ]; then
				CurLine=${CurLineNoTrail//<C>}

				if [ "$ESCAPE" == 'true' ]; then
					printf "%*b\n" $[((Cols / 2) + CurLineHalf) - 2] "$CurLine"
				else
					printf "%*s\n" $[((Cols / 2) + CurLineHalf) - 2] "$CurLine"
				fi
			elif [ "${CurLineNoSpace:0:3}" == '<R>' ]; then
				CurLine=${CurLineNoTrail//<R>}

				if [ "$ESCAPE" == 'true' ]; then
					printf "%*b\n" $[Cols - ${#CurLineHalf}] "$CurLine"
				else
					printf "%*s\n" $[Cols - ${#CurLineHalf}] "$CurLine"
				fi
			else
				if [ "$ESCAPE" == 'true' ]; then
					printf "  %b\n" "$CurLineNoTrail"
				else
					printf "  %s\n" "$CurLineNoTrail"
				fi
			fi

			let BodyLines++
			OldLine=$CurLine
		else
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 "$LINENO" "Line $BodyLines of slide $SlideNumber is too long."
		fi
	fi

	let MainLines++
}

CursorDown

if [ "$INTERACTIVE" == 'true' ]; then
	PAKTC
else
	sleep ${WaitTime}s
fi

[ "$DEBUGME" == 'true' ] || tput clear
