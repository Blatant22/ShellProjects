#!/usr/bin/env bash

#----------------------------------------------------------------------------------
# Project Name      - Extra/shlides
# Started On        - Sun 17 Nov 16:27:40 GMT 2019
# Last Change       - Fri 22 Nov 12:42:51 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

if [ -z "$BASH" ]; then
	printf "The Bourne Again Shell is required to run shlides.\n" 1>&2
	exit 1
fi

_VERSION_="2019-11-22"
_PROJECT_="${0##*/}"

FAIL(){
	printf "[L%0.4d] ERROR: %s\n" "$2" "$3" 1>&2
	[ $1 -eq 1 ] && exit 1
}

BASHDEBUG='false'

DEBUG(){
	if [ "$BASHDEBUG" == 'true' ]; then
		set -x
	elif [ "$DEBUGME" == "true" ]; then
		if [ $# -eq 3 ]; then
			printf "[L%0.4d] DEBUG(\$%s): '%s'\n" "$1" "$2" "$3"
		elif [ $# -eq 2 ]; then
			printf "[L%0.4d] DEBUG: %s\n" "$1" "$2"
		else
			FAIL 1 $LINENO "Invalid 'DEBUG()' argument(s)."
		fi
	fi
}

DOM="https://github.com"

USAGE(){
	while read -r; do
		printf "%s\n" "$REPLY"
	done <<-EOF
		            ${_PROJECT_^^} ($_VERSION_)
		            Written by terminalforlife (terminalforlife@yahoo.com)

		            Present a project on your terminal via formatted slides.

		SYNTAX:     $_PROJECT_ [OPTS] FILE

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --update|-U             - Check for updates to $_PROJECT_.
		            --debug|-D              - Enables debugging information.
		            --interactive|-i        - Wait for the user to press a key.
		            --tildes|-T             - Use the EOF tildes like in vim.
		            --escape|-E             - Allow terminal escape sequences.
		            --no-header             - Omit the header from each slide.
		            --no-footer             - Omit the footer from each slide.
		            --effect|-e             - Apply a downward sweeping effect.
		            --borders|-b            - Pretty borders around the header.
		            --bstyle|-B STYLE       - Select the border STYLE to use.
		            --ascii|-A              - Interface uses only ASCII characters.
		            --wait|-w INT           - Wait INT second(s) between slides.
		            --skip-start|-s         - Skip the message at project start.

		BORDER:     The border styles, shown using ASCII, currently available:

		              'default'

		                 +-------------------------------------------------------+
		                 |                        'header'                       |
		                 +-------------------------------------------------------+

		                 +-------------------------------------------------------+
		                 |  footer left                            footer right  |
		                 +-------------------------------------------------------+

		              'oneline'             -

		                 -----------------------| 'header' |----------------------

		                 --| footer left |----------------------| footer right |--

		            Border styles do not impact the position of the slide body, in
		            order to keep things as consistent as possible.

		SITE:       $DOM/terminalforlife/Extra
	EOF
}

BSTYLE='default'
WaitTime=1
EffectDelay=0.03

while [ "$1" ]; do
	case $1 in
		--help|-h|-\?)
			USAGE; exit 0 ;;
		--version|-v)
			printf "%s\n" "$_VERSION_"; exit 0 ;;
		--update|-U)
			UPDATE='true'

			DEBUG $LINENO "UPDATE" "$UPDATE" ;;
		--debug|-D)
			DEBUGME='true'

			DEBUG $LINENO "DEBUGME" "$DEBUGME" ;;
		--interactive|-i)
			INTERACTIVE='true'

			DEBUG $LINENO "INTERACTIVE" "$INTERACTIVE" ;;
		--tildes|-T)
			USETILDES='true'

			DEBUG $LINENO "USETILDES" "$USETILDES" ;;
		--escape|-E)
			ESCAPE='true'

			DEBUG $LINENO "ESCAPE" "$ESCAPE" ;;
		--no-header)
			NOHEADER='true'

			DEBUG $LINENO "NOHEADER" "$NOHEADER" ;;
		--no-footer)
			NOFOOTER='true'

			DEBUG $LINENO "NOFOOTER" "$NOFOOTER" ;;
		--effect|-e)
			EFFECT='true'

			DEBUG $LINENO "EFFECT" "$EFFECT" ;;
		--borders|-b)
			BORDERS='true'

			DEBUG $LINENO "BORDERS" "$BORDERS" ;;
		--bstyle|-B)
			shift

			case $1 in
				default|oneline) BSTYLE=$1 ;;
				*) FAIL 1 $LINENO "Unrecognised border style." ;;
			esac

			DEBUG $LINENO "BSTYLE" "$BSTYLE" ;;
		--ascii|-A)
			ASCII='true'

			DEBUG $LINENO "ASCII" "$ASCII" ;;
		--wait|-w)
			shift

			if [[ $1 =~ ^([0-9]+|[0-9]+\.[0-9]+)$ ]]; then
				WaitTime=$1
				WAIT='true'

				DEBUG $LINENO "WaitTime" "$WaitTime"
				DEBUG $LINENO "WAIT" "$WAIT"
			else
				FAIL 1 $LINENO "Specified wait time is invalid."
			fi ;;
		--skip-start|-s)
			SKIPSTART='true'

			DEBUG $LINENO "SKIPSTART" "$SKIPSTART" ;;
		-*)
			DEBUG $LINENO "1" "$1"

			FAIL 1 $LINENO "Incorrect argument(s) specified." ;;
		*)
			DEBUG $LINENO "1" "$1"
			DEBUG $LINENO "Breaking from parameter while loop."

			break ;;
	esac

	DEBUG $LINENO "*" "$*"
	DEBUG $LINENO "Shifting positional parameters."

	shift
done

if [ "$WAIT" == 'true' -a "$INTERACTIVE" == 'true' ]; then
	FAIL 1 $LINENO "Either '--wait|-w' or '--interactive|-i', not both."
elif [ "$BORDERS" == 'true' ]; then
	if [ "$NOHEADER" == 'true' ]; then
		FAIL 1 $LINENO "Option '--borders|-b' used but header disabled."
	elif [ "$NOFOOTER" == 'true' ]; then
		FAIL 1 $LINENO "Option '--borders|-b' used but footer disabled."
	fi
fi

DEBUG $LINENO "Checking for 'tput' PATH executable."

if ! type -fP tput > /dev/null 2>&1; then
	FAIL 0 $LINENO "Dependency 'tput' not met."
fi

if [ "$UPDATE" == "true" ]; then
	DEBUG $LINENO "Beginning procedure to check for an update."

	if ! type -fP wget > /dev/null 2>&1; then
		FAIL 1 $LINENO "Dependency 'wget' not met."
	fi

	VERSION_URL="$DOM/terminalforlife/Extra/raw/master/versions"
	while IFS='=' read -a LINE; do
		if  [ "${LINE[0]}" == "$_PROJECT_" ]; then
			LATEST="${LINE[1]}"
			DEBUG $LINENO "LATEST" "$LATEST"

			if [[ "${LATEST//-}" =~ ^[0-9]{8}$ ]]; then
				DEBUG $LINENO "Self version detection successful."

				if [ ${LATEST//-} -gt ${_VERSION_//-} ]; then
					while read -r; do
						printf "%s\n" "$REPLY"
					done <<-EOF
						New version available:    $LATEST
						Current version:          $_VERSION_
					EOF
				fi
			else
				FAIL 1 $LINENO "Failed to check for available updates."
			fi
		fi
	done <<< "$(wget -q "$VERSION_URL" -O -)"

	exit 0
fi

DEBUG $LINENO "1" "$1"

if [ -z "$1" ]; then
	FAIL 1 $LINENO "A project file wasn't provided."
elif [ -f "$1" ] && [ -r "$1" ]; then
	ProjectFile=$1

	DEBUG $LINENO "ProjectFile" "$ProjectFile"
	DEBUG $LINENO "Shifting positional parameters."

	shift

	[ $# -gt 0 ] && FAIL 1 $LINENO "Only one project may run at a time."
elif [[ "$1" ]]; then
	FAIL 1 $LINENO "A project file wasn't provided."
else
	FAIL 1 $LINENO "Project file missing or unreadable."
fi

tput smcup

RED=`tput setaf 1`; BLUE=`tput setaf 4`; GREEN=`tput setaf 2`
BOLD=`tput bold` WHITE=`tput setaf 7`; YELLOW=`tput setaf 3`
GREY=`tput setaf 0` NORM=`tput cnorm`

if ! [ "$ASCII" == 'true' ]; then
	BP='⟐' # <-- Non-ASCII Bullet Point.
	SB='│' # <-- Non-ASCII Side Border.
else
	BP='*' # <-- ASCII Bullet Point.
	SB='|' # <-- ASCII Side Border.
fi

PAKTC(){
	read -sn 1
	printf "\n"
}

Cols=${COLUMNS:-`tput cols`}
Lines=${LINES:-`tput lines`}

DEBUG $LINENO "COLUMNS" "$COLUMNS"
DEBUG $LINENO "LINES" "$LINES"
DEBUG $LINENO "Cols" "$Cols"
DEBUG $LINENO "Lines" "$Lines"

# Ensure column and line counts are updated, even after window resizing.
trap 'Cols=${COLUMNS:-`tput cols`}; Lines=${LINES:-`tput lines`}' WINCH

# Function for handling the correct number of line characters.
UnderLine(){
	DEBUG $LINENO "Function 'UnderLine()' called."
	DEBUG $LINENO "1" "$1"
	DEBUG $LINENO "2" "$2"
	DEBUG $LINENO "3" "$3"

	[ "$ASCII" == 'true' ] && { A=1; B=2; } || { A=0; B=1; }

	DEBUG $LINENO "A" "$A"
	DEBUG $LINENO "B" "$B"

	for ((I=1; I<Cols; I++)); {
		if [ $I -eq 1 ]; then
			printf "%s" ${1:A:B}
		elif [ $I -eq $((Cols - 1)) ]; then
			printf "%s" ${3:A:B}
		else
			printf "%s" ${2:A:B}
		fi
	}
}

Header(){
	printf "\n" # <-- Fixes weird missing line 1 bug in header.

	ColsSubstr=${Cols:$[${#Cols} - 2]:1}
	[[ $ColsSubstr == [13579] ]] && let Cols++

	DEBUG $LINENO "Function 'Header()' called."
	DEBUG $LINENO "1" "$1"
	DEBUG $LINENO "2" "$2"
	DEBUG $LINENO "3" "$3"

	Title="'${2//_/ }'"

	if [ "$BORDERS" == 'true' ]; then
		if [ "$BSTYLE" == 'oneline' ]; then
			[ "$ASCII" == 'true' ] && Y='-' || Y='─'
			for ((I=1; I<Cols; I++)); {
				printf "%s" "$Y"
			}

			Title="| '${2//_/ }' |"
		fi
	fi

	TitleTest=${2//_/ }

	if [ -n "$TitleTest" ]; then
		TitleHalf=$[${#Title} / 2]
		TitleEndAlign=$[(Cols - ${#Title}) + 1]
		TitlePush=$TitleEndAlign

		DEBUG $LINENO "Title" "$Title"
		DEBUG $LINENO "TitleHalf" "$TitleHalf"
		DEBUG $LINENO "TitleEndAlign" "$TitleEndAlign"
		DEBUG $LINENO "TitlePush" "$TitlePush"

		if [ "$BORDERS" == 'true' ]; then
			if [ "$BSTYLE" == 'default' ]; then
				DEBUG $LINENO "Processing the 'default' header border style."

				UnderLine '╭+' '─-' '╮+'

				# Addresses bizarre bug with non-ASCII header. (right side)
				[ "$ASCII" == 'true' ] && local A=0 || local A=2

				printf "%s%*s%*s\n" "$SB" $[((Cols / 2) + TitleHalf) - 2]\
					"$Title" $[((Cols / 2) - TitleHalf) + A] "$SB"

				UnderLine '╰+' '─-' '╯+'
			elif [ "$BSTYLE" == 'oneline' ]; then
				DEBUG $LINENO "Processing the 'oneline' header border style."

				tput cup 1 $[((Cols / 2) - TitleHalf) - 2]
				printf "%s" "$Title"
			fi
		else
			DEBUG $LINENO "Processing the borderless header."

			printf "%*s" $[((Cols / 2) + TitleHalf) - 2] "$Title"
		fi
	else
		tput clear
		FAIL 1 $LINENO "Slide #${SlideNumber:-?} has no header title."
	fi
}

CursorDown(){
	[ "$DEBUGME" == 'true' ] || tput cup ${1:-$Lines} ${2:-$Cols}
}

Footer(){
	CursorDown $[Lines - 3] $Cols
	printf " " # <-- Seems to correct mis-algnment.

	ColsSubstr=${Cols:$[${#Cols} - 1]:1}
	[[ $ColsSubstr == [13579] ]] && let Cols++

	DEBUG $LINENO "Function 'Footer()' called."
	DEBUG $LINENO "1" "$1"
	DEBUG $LINENO "2" "$2"
	DEBUG $LINENO "3" "$3"

	if [ "$BORDERS" == 'true' ]; then
		if [ "$BORDERS" == 'true' ]; then
			if [ "$BSTYLE" == 'default' ]; then
				DEBUG $LINENO "Processing the 'default' footer border style."

				FooterTextLeft="FILE: '${ProjectFile##*/}' $BP SLIDE: $SlideNumber "
				FooterTextRight="BODY: L$[Cols - 2] C$[Lines - 8] $BP HOST: $HOSTNAME"

				UnderLine '╭+' '─-' '╮+'

				if [ $[${#FooterTextLeft} + ${#FooterTextRight}] -lt $[Cols - 10] ]; then
					tput cup $Lines
					printf "$SB $FooterTextLeft"
					tput cup $Lines $[(Cols - ${#FooterTextRight}) - 3]
					printf "$FooterTextRight $SB"
				else
					[ "$DEBUGME" == 'true' ] || tput clear
					FAIL 1 $LINENO "Insufficent space for the footer."
				fi

				UnderLine '╰+' '─-' '╯+' || printf "\n"
			elif [ "$BSTYLE" == 'oneline' ]; then
				DEBUG $LINENO "Processing the 'online' footer border style."

				tput cup $[$Lines - 2] 0
				[ "$ASCII" == 'true' ] && Y='-' || Y='─'
				for ((I=1; I<Cols; I++)); {
					printf "%s" "$Y"
				}

				FooterTextLeft="$SB FILE: '${ProjectFile##*/}' $BP SLIDE: $SlideNumber $SB"
				FooterTextRight="$SB BODY: L$[Cols - 2] C$[Lines - 8] $BP HOST: $HOSTNAME $SB"

				if [ $[${#FooterTextLeft} + ${#FooterTextRight}] -lt $[Cols - 10] ]; then
					tput cup $[$Lines - 2] 2
					printf "$FooterTextLeft"
					tput cup $[$Lines - 2] $[(Cols - ${#FooterTextRight}) - 3]
					printf "$FooterTextRight"
				else
					[ "$DEBUGME" == 'true' ] || tput clear
					FAIL 1 $LINENO "Insufficent space for the footer."
				fi

			fi
		fi
	else
		DEBUG $LINENO "Processing the borderless footer."

		FooterTextLeft="FILE: '${ProjectFile##*/}' $BP SLIDE: $SlideNumber "
		FooterTextRight="BODY: L$[Cols - 2] C$[Lines - 8] $BP HOST: $HOSTNAME"

		if [ $[${#FooterTextLeft} + ${#FooterTextRight}] -lt $[Cols - 10] ]; then
			tput cup $[$Lines - 2]
			printf "  $FooterTextLeft"
			tput cup $[$Lines - 2] $[(Cols - ${#FooterTextRight}) - 3]
			printf "$FooterTextRight  "
		else
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 $LINENO "Insufficent space for the footer."
		fi
	fi

	DEBUG $LINENO "FooterTextLeft" "$FooterTextLeft"
	DEBUG $LINENO "FooterTextRight" "$FooterTextRight"
}

[ "$DEBUGME" == 'true' ] || tput clear

# Short, optional introduction of shlides.
if ! [ "$SKIPSTART" == 'true' ]; then
	tput cup $[(Lines / 2) - 1]
	Text="Presentation created with shlides, version $_VERSION_."
	printf "${RED}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"

	tput cup $[(Lines / 2) - 0]
	Text="Written by 'terminalforlife', also known as 'Learn Linux'."
	printf "${YELLOW}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"

	tput cup $[(Lines / 2) + 1]
	Text="Licensed under the 'GNU General Public License v3.0'."
	printf "${YELLOW}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"

	tput cup $[(Lines / 2) + 3]
	Text="https://github.com/terminalforlife"
	printf "${WHITE}%*s${WHITE}" $[(Cols / 2) + (${#Text} / 2)] "$Text"
else
	DEBUG $LINENO "Skipping the splash screen."
fi

# Output and parse lines of body.
FirstLineFromBuffArr='false'
readarray BuffArr < "$ProjectFile"
for L in "${BuffArr[@]%$'\n'}"; {
	if [ "$DoSkipSlide" == 'true' ] || [[ $L == \#\ * ]]; then
		continue
	elif [[ $L =~ ^###\  ]]; then
		if [ "$FirstLineFromBuffArr" == 'true' ]; then
			FirstLineFromBuffArr='true'
		else
			CursorDown
			unset FirstLineFromBuffArr
		fi

		if [ -n "$OldLine" ]; then
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 $LINENO "Line '$BodyLines' is non-empty."
		elif [ ${BodyLines:-0} -gt $[Lines - 8] ]; then
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 $LINENO "Line overflow ($BodyLines/$[Lines - 8]) in the body of slide #$SlideNumber."
		fi

		if [ "$INTERACTIVE" == 'true' ]; then
	  		PAKTC
		else
			sleep ${WaitTime}s
		fi

		[ "$DEBUGME" == 'true' ] || tput clear

		MainLines=1
		BodyLines=0
	fi

	DEBUG $LINENO "MainLines" "$MainLines"

	#printf "M%d:" "$MainLines"
	if [ $MainLines -eq 1 ]; then
		# Gather header commands (key=value), and catch errors.
		FieldCount=0
		for Field in $L; {
			let FieldCount++

			DEBUG $LINENO "Field" "$Field"

			if [ ! "$HeaderPrefixFound" == 'true' -a "$Field" == '###' ]; then
				HeaderPrefixFound='true'
				continue
			elif [ "$HeaderPrefixFound" == 'true' -a "$Field" == '###' ]; then
				[ "$DEBUGME" == 'true' ] || tput clear
				FAIL 1 $LINENO "Only one header prefix is required."
			else
				unset HeaderPrefixFound
			fi

			if [[ $Field == *=* ]]; then
				DEBUG $LINENO "Valid field found."

				IFS='=' read -a FieldArray <<< "$Field"

				DEBUG $LINENO "FieldArray" "$FieldArray"
				if [ "${FieldArray[0]}" == "SLIDE" ]; then
					SlideNumber=${FieldArray[1]}
					DEBUG $LINENO "SlideNumber" "$SlideNumber"
				elif [ "${FieldArray[0]}" == "TITLE" ]; then
					SlideTitle=${FieldArray[1]//\"}
					DEBUG $LINENO "SlideTitle" "$SlideTitle"
				else
					[ "$DEBUGME" == 'true' ] || tput clear
					FAIL 1 $LINENO "Invalid header command at field $FieldCount."
				fi
			else
				[ "$DEBUGME" == 'true' ] || tput clear
				FAIL 1 $LINENO "Invalid header field at position $FieldCount."
			fi
		}

		# Actually display the header, based on `*.shl` header commands.
		if [ "$NOHEADER" == 'true' ]; then
			# If disabled, just ensure a blank line for tidiness.
			printf "\n"
		else
			Header $SlideNumber "$SlideTitle"
		fi

		[ "$NOFOOTER" == 'true' ] || Footer
		CursorDown 4 0
	elif [ $MainLines -eq 2 ]; then
		if [ -n "$L" ]; then
			DEBUG $LINENO "L" "$L"

			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 $LINENO "Line 2 is non-empty."
		fi
	elif [ $MainLines -gt 2 ]; then
		# Display the body of the current slide.
		if ! [ ${#L} -gt $[Cols - 5] ]; then
			[ "$EFFECT" == 'true' ] && sleep $EffectDelay

			EscapeCondition(){
				[ "$ESCAPE" == 'true' ] && Format='b'
				printf "%*${Format:-s}\n" $1 "$2"
			}

			LNoTrail=${L%%[[:space:]]}
			LHalf=$[${#L} / 2]
			LNoSpace=${L//[[:space:]]/}

			if [ "${LNoSpace:0:3}" == '<C>' ]; then
				EscapeCondition $[((Cols / 2) + LHalf) - 3] "${LNoTrail//<C>}"
			elif [ "${LNoSpace:0:3}" == '<R>' ]; then
				EscapeCondition $[Cols - 3] "${LNoTrail//<R>}"
			else
				if [ "$ESCAPE" == 'true' ]; then
					printf "  %b\n" "$LNoTrail"
				else
					printf "  %s\n" "$LNoTrail"
				fi
			fi

			let BodyLines++
			OldLine=$L
		else
			[ "$DEBUGME" == 'true' ] || tput clear
			FAIL 1 $LINENO "Line $BodyLines of slide #$SlideNumber is too long."
		fi
	fi

	let MainLines++
}

CursorDown

if [ "$INTERACTIVE" == 'true' ]; then
	PAKTC
else
	sleep ${WaitTime}s
fi

[ "$DEBUGME" == 'true' ] || tput rmcup
