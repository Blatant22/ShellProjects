#!/bin/bash

#----------------------------------------------------------------------------------
# Project Name      - Extra/mkpass
# Started On        - Fri 20 Oct 12:14:09 BST 2017
# Last Change       - Sun 12 May 23:14:45 BST 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

_VERSION_="2019-05-12"
_PROJECT_="${0##*/}"

FAIL(){
	printf "[L%0.4d] ERROR: %s\n" "$2" "$3" 1>&2
	[ $1 -eq 1 ] && exit 1
}

USAGE(){
	while read -r; do
		printf "%s\n" "$REPLY"
	done <<-EOF
		            ${_PROJECT_^^} ($_VERSION_)
		            Written by terminalforlife (terminalforlife@yahoo.com)

		            Pure Bourne Again Shell approach to complex password generation.

		SYNTAX:     $_PROJECT_ [OPTS] INT

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --type|-t TYPE          - Where T is the type. See below.

		NOTE:       This small program uses /dev/urandom to generate a wide range of
		            characters, just as you would expect from genpass, but fuller and
		            with extra features and choices for the user.

		            Where INT is the number (integer) of characters to generate.

		TYPES:      Available TYPEs:

		            +------------+----------------------+------------------+
		            | VALID TYPE | WHAT IT INCLUDES     | REGEX FORM       |
		            +------------+----------------------+------------------+
		            | punct      | Punctuation          | [[:punct:]]      |
		            | digit      | Digits               | [[:digit:]]      |
		            | alpha      | Letters              | [[:alpha:]]      |
		            | alnum      | Letters and Digits   | [[:alnum:]]      |
		            | alphapunct | All of the above.    | [[:alphapunct:]] |
		            +-----------------------------------+------------------+
	EOF
}

while [ "$1" ]; do
	case "$1" in
		--help|-h|-\?)
			USAGE; exit 0 ;;
		--version|-v)
			printf "%s\n" "$_VERSION_"; exit 0 ;;
		--type|-t)
			shift; TYPE="$1" ;;
		-*)
			FAIL 1 "$LINENO" "Incorrect argument(s) specified." ;;
		*)
			break ;;
	esac
	shift
done

if [[ "$1" =~ [0-9]+ ]]; then
	INT=$1
elif [ -z "$INT" ]; then
	FAIL 1 "$LINENO" "Invalid or missing INT."
elif ! [ -e /dev/urandom ]; then
	FAIL 1 "$LINENO" "Unable to access /dev/urandom device."
elif ! [[ "$*" =~ [0-9]+ ]] && [ "$INT" -ge 1 ]; then
	FAIL 1 "$LINENO" "Requires an integer greater than or equal to 1."
fi

case "${TYPE:-EMPTY}" in
	punct)
		CHARS='[\`/\+\\\|\_\,\.\?\!\"\\\/\$\%\^\&\*\(\)\{\}\]\[-\>\<\:\@\~]' ;;
	digit)
		CHARS='[0-9]' ;;
	alpha)
		CHARS='[A-Za-z]' ;;
	alnum)
		CHARS='[0-9A-Za-z]' ;;
	alphapunct|EMPTY)
		CHARS='[\`/\+\\\|0-9A-Za-z\_\,\.\?\!\"\\\/\$\%\^\&\*\(\)\{\}\]\[-\>\<\:\@\~]' ;;
	*)
		FAIL 1 "$LINENO" "Invalid TYPE selected." ;;
esac

declare -i A=0
while read -a X; do
	if [[ "${X:0:1}" == $CHARS ]]; then
		A+=1
		printf "%s" "${X:0:1}"
		[ $A -eq $INT ] && break
	fi
done < /dev/urandom

printf "\n"

# vim: noexpandtab colorcolumn=84 tabstop=8 noswapfile nobackup
