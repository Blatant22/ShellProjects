#!/bin/sh
#cito M:755 O:0 G:0 T:/usr/bin/yol
#------------------------------------------------------------------------------
# Project Name      - Extra/source/yol/yol
# Started On        - Tue  3 Mar 23:50:03 GMT 2020
# Last Change       - Wed  4 Mar 03:08:43 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# This year will definitely be the Year of Linux, right? Either way, this is
# yet another command-line calendar-type program, this time written in Bourne.
#
# Unlike other similar calendar-style programs, YoL only focuses on the current
# year, because of course, this is the Year of Linux!
#
# Features:
#
# N/A
#
# Bugs:
#
# N/A
#
# Dependencies:
#
#   coreutils (>= 8.28-1)
#   libtflbp-sh (>= 2019-12-10)
#   wget (>= 1.17.1-1)
#------------------------------------------------------------------------------

set -e
. /usr/lib/tflbp-sh/Err
. /usr/lib/tflbp-sh/ChkDep
set +e

CurVer='2020-03-04'
Progrm=${0##*/}

Usage(){
	while read -r CurLine; do
		printf '%b\n' "$CurLine"
	done <<-EOF
		\rUsage: $Progrm [OPTS] [DAY] [MONTH]

		\r  -h, --help               - Display this help information.
		\r  -v, --version            - Output the version datestamp.
		\r  -a, --add TEXT           - Add STR entry to the calendar.
		\r  -r, --remove HH:MM:SS    - Remove entry made at this time.

		NOTE: If no MONTH is provided, the current one will be assumed. If no
		      DAY is provided, the same logic applies.

		IE:   $Progrm  --add 'Example entry.' 4 March
		      $Progrm  -r 21:10:25 18 December
	EOF
}

while [ "$1" ]; do
	case $1 in
		--help|-h|-\?)
			Usage; exit 0 ;;
		--version|-v)
			printf '%s\n' "$CurVer"; exit 0 ;;
		--add|-a)
			Add='true'
			NewEntry=$2

			if [ -z "$NewEntry" ]; then
				Err 1 "Option '$1' requires an argument."
			fi

			shift ;;
		--remove|-r)
			Remove='true'
			RemoveEntry=$2

			if [ -z "$RemoveEntry" ]; then
				Err 1 "Option '$1' requires an argument."
			else
				case $RemoveEntry in
					[0-9][0-9]:[0-9][0-9]:[0-9][0-9]) ;;
					*) Err 1 "Invalid time (HH:MM:SS) provided." ;;
				esac
			fi

			shift ;;
		-*)
			Err 1 'Incorrect option(s) specified.' ;;
		*)
			break ;;
	esac
	shift
done

ChkDep ncal date mkdir md5sum grep sed fold

Today=`date '+%e %B %Y'`
NowDay=${Today%% *}
NowMonth=${Today% *}
NowMonth=${NowMonth#* }
NowYear=${Today##* }

MainDir="$HOME/.config/$Progrm"
[ -d "$MainDir" ] || mkdir -p "$MainDir"
CalDir="$MainDir/calendar"
[ -d "$CalDir" ] || mkdir -p "$CalDir"

Months='January February March April May June July August '
Months="$Months September October November December"

PrettyNum(){
	case $1 in
		      *1) Suffix='st' ;;
		      *2) Suffix='nd' ;;
		      *3) Suffix='rd' ;;
		*4|12|*0) Suffix='th' ;;
	esac

	printf '%s' "$Suffix"
}

# Generate a list of directories for each month, and use ncal(1) to determine
# the days for each, paired up with `printf` to zero-pad the numbers, creating
# a file for each day, within each respective monthly directory.
First='true'
for Month in $Months; do
	[ -d "$CalDir/$Month" ] || mkdir -p "$CalDir/$Month"

	ncal -M $Month $NowYear | while read Line; do
		if [ "$First" = 'true' ]; then
			unset First
			continue
		fi

		for Day in ${Line#* }; do
			DayFile="$CalDir/$Month/$Day"
			[ -f "$DayFile" ] || 1> "$DayFile"
		done
	done
done

EntryFile="$CalDir/${2:-$NowMonth}/${1:-$NowDay}"

if [ "$Add" = 'true' ]; then
	Time=`date '+%X'`
	MD5=`printf '%s' "$NewEntry" | md5sum`
	MD5=${MD5%% *}

	if [ -f "$EntryFile" ] && ! [ -w "$EntryFile" ]; then
		Err 1 "File '~${EntryFile#$HOME}' lacks write access."
	elif grep -qs "|$MD5|" "$EntryFile"; then
		Err 1 'Detected existing entry of the same hash.'
	fi

	printf '%s|%s|%s\n' "$Time" "$MD5" "$NewEntry" >> "$EntryFile"
	printf "Entry '%s' added.\n" "$MD5"

	exit 0
elif [ "$Remove" = 'true' ]; then
	DayNum="$1$(PrettyNum $1)"

	if [ -f "$EntryFile" ] && ! [ -w "$EntryFile" ]; then
		Err 1 "File '~${EntryFile#$HOME}' lacks write access."
	elif ! grep -qs "^$RemoveEntry|" "$EntryFile"; then
		Err 1 "Entry for $DayNum $2, made at $RemoveEntry not found."
	fi

	if ! sed -i "/^$RemoveEntry|/d" "$EntryFile" 1> /dev/null 2>&1; then
		Err 1 'Failed to remove entry.'
	fi

	exit 0
fi

while IFS='|' read Time Hash Entry; do
	printf '%s: %s\n' "$Time" "$Entry"
done < "$EntryFile"

# Code to simply view the entry, per the provided date, down here.
