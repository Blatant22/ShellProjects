#!/usr/bin/env bash
#cito M:755 O:0 G:0 T:/usr/bin/freelfm
#------------------------------------------------------------------------------
# Project Name      - Extra/source/freelfm
# Started On        - Fri 15 Sep 21:19:42 BST 2017
# Last Change       - Fri 12 May 22:46:13 BST 2023
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# Download last.fm's free music into the current working directory.
#
# The current max page is 12. The total number is 220+ MP3 tracks. Except the
# tracks themselves, the files are saved in '/tmp'.
#
# Downloaded tracks will not clobber those partially-downloaded.
#
# Does not show you a total number of tracks available, because that would
# require unnecessarily parsing every single page, when the user might not want
# all of them. Therefore, not providing this output seems more respectiful to
# the server(s) hosting the tracks. As a result, FreeLFM is faster.
#
# Features:
#
#TODO: Add a target directory flag.
#TODO: Provide range feature as an argument. Like `freelfm 2-7`. Think WCDL.
#
# Bugs:
#
#TODO: Multiple duplicate pages can be provided by the user -- handle this.
#
# Dependencies:
#
#   coreutils (>= 8.25-2)
#   wget (>= 1.17.1-1)
#------------------------------------------------------------------------------

CurVer='2023-05-12'
Progrm=${0##*/}

Usage() {
	read -d '' <<-EOF
		Usage: $Progrm [OPTS] PAGE [PAGE ...]

		  -h, --help               - Displays this help information.
		  -v, --version            - Output only the version datestamp.
		  -a, --act {sd|ss}        - When done, either shut down or suspend.
		  -O, --links-only         - List download URLs instead of downloading.
	EOF

	printf '%s' "$REPLY"
}

Err() {
	printf 'Err: %s\n' "$2" 1>&2
	(( $1 > 0 )) && exit $1
}

LinksOnly=
PowerAct=
PageURL='https://www.last.fm/music/+free-music-downloads?page'

while [[ -n $1 ]]; do
	case $1 in
		--help|-h)
			Usage; exit 0 ;;
		--version|-v)
			printf '%s\n' "$CurVer"; exit 0 ;;
		--act|-a)
			case ${2,,} in
				ss|sd)
					PowerAct=$2 ;;
				'')
					Err 1 "Option '$1' requires an argument." ;;
				*)
					Err 1 "Option '$1' given invalid argument." ;;
			esac
			shift ;;
		-O|--links-only)
			LinksOnly='True' ;;
		-*)
			Err 1 'Incorrect argument(s) specified.' ;;
		*)
			break ;;
	esac
	shift
done

DepCount=0
for CurDep in wget sleep systemctl; {
	if ! type -P "$CurDep" &> /dev/null; then
		[[ $CurDep == systemctl && -z $PowerAct ]] && continue

		Err 0 "Dependency '$CurDep' not met."
		(( DepCount++ ))
	fi
}

(( DepCount > 0 )) && exit 1

(( $# == 0 )) && Err 1 "Page number(s) required -- see: $Progrm -h"

#----------------------------------------------------------------Main Functions

# I know this can be done in a simple way using BASH's parameter expansion's
# pattern substitution, but this was a huge pain to figure out, and I'm quite
# proud of it, so it's here to stay. After testing, it turns out this method
# is ever so slightly faster, although it took 1000 iterations to even notice
# that negible amount.
#
# Usage: DecodeURL VARIABLE URL
DecodeURL() {
	declare -n Return=$1
	URL=$2

	OutChars=
	HexChars=
	HexFound=
	Len=${#URL}
	for (( Index = 0; Index < Len; Index++ )); {
		CurChar=${URL:Index:1}
		if [[ $HexFound == True ]]; then
			HexChars+=$CurChar
			HexTest="\x$HexChars"

			# Have to use `printf` here, due to limitations of shell. I could
			# use the $'...' syntax, but the shell won't allow a variable
			# where the elipsis is, and you weirdly must use single-quotes. The
			# only way I know around that is to use `eval`, unfortunately.
			#
			# Note that `printf` will spit out a null value if so-called not
			# valid. Hence using the character class to check it's actually
			# printable, vs. just checking the variable is not empty.
			printf -v HexTest "\x$HexChars"

			if [[ $HexTest == [[:print:]] ]]; then
				OutChars+=$HexTest
				HexFound=
				HexChars=
			fi
		elif [[ $CurChar == % ]]; then
			HexFound='True'
		elif [[ $CurChar == '+' ]]; then
			OutChars+=' '
		else
			OutChars+=$CurChar
		fi
	}

	Return=$OutChars
}

Info() {
	[[ $LinksOnly == True ]] || printf '%s\n' "$1"
}

#----------------------------------------------------Determine Valid Page Range

Info 'Looking for available pages.'

# Kinder to the servers if page 1 is later requested.
Page1Data=`wget -qO - "$PageURL=1"`

PagesFound=()
while read; do
	if [[ $REPLY == *'<a href="?page='+([[:digit:]])'">'* ]]; then
		for Digits in ${REPLY//[^[:digit:]]/ }; {
			FoundDupe=
			for Page in "${PagesFound[@]}"; {
				if [[ $Page == $Digits ]]; then
					FoundDupe='True'

					break
				fi
			}

			[[ $FoundDupe == True ]] || PagesFound+=($Digits)
		}
	fi
done <<< "$Page1Data"

# Ensure we know the maximum page by sorting.
Len=${#PagesFound[@]}
for (( Iter = 0; Iter <= Len; Iter++ )); {
	Switched='False'
	for (( Index = 0; Index < Len - (1 + Iter); Index++ )); {
		if (( ${PagesFound[Index]} < ${PagesFound[Index + 1]} )); then
			Temp=${PagesFound[Index]}
			PagesFound[Index]=${PagesFound[Index + 1]}
			PagesFound[Index + 1]=$Temp

			Switched='True'
		fi
	}

	[[ $Switched == False ]] && break
}

PageMax=${PagesFound[0]}

Info "Found $PageMax available page(s)."

#----------------------------------Fetch List of Track URLs Per the Valid Pages

for PageNr; {
	if [[ $PageNr != +([0-9]) ]]; then
		Err 0 "Page number '$PageNr' invalid."
		continue
	elif ! (( PageNr >= 1 && PageNr <= PageMax )); then
		Err 0 "Page number '$PageNr' not found."
		continue
	fi

	Info "Scanning page $PageNr."

	CurPageURL="$PageURL=$PageNr"

	if (( PageNr == 1 )); then
		PageData=$Page1Data
	else
		PageData=`wget -qO - "$CurPageURL"`
	fi

	Info 'Looking for tracks.'

	# Grab direct download link for each track.
	TrackURLs=()
	TrackTotal=0
	while read; do
		if [[ $REPLY == *\"https:*.mp3\"* ]]; then
			FileURL=${REPLY#*https://}
			FileURL=${FileURL%.mp3*}
			FileURL="https://$FileURL.mp3"
			TrackURLs+=("$FileURL")

			(( TrackTotal++ ))
		fi
	done <<< "$PageData"

	Info "Found $TrackTotal track(s) on page $PageNr."
}

#-------------------------------------------Begin Downloading or Listing Tracks

if [[ $LinksOnly == True ]]; then
	printf '%s\n' "${TrackURLs[@]}"
else
	for TrackURL in "${TrackURLs[@]}"; {
		TrackName=${TrackURL##*/}

		# Cleanse the filename for our local version.
		DecodeURL TrackName "$TrackName"

		Info "Found: ${TrackName%.mp3}"
		if wget -qc -O ./"$TrackName" "$TrackURL"; then
			Info 'Downloaded successful.'
		else
			Info 'Error(s) detected.'
		fi
	}
fi

Info 'Finished!'

#-------------------------------------------------Power Down or Suspend Machine

if [[ -n $PowerAct ]]; then
	read -d '' <<-EOF
		WARNING: System shutdown in 30 seconds!
		         Press Ctrl + C to cancel, ...
	EOF

	printf '%s' "$REPLY"

	sleep 30s || exit 0
	case $PowerAct in
		sd) systemctl shutdown ;;
		ss) systemctl suspend ;;
	esac
fi
