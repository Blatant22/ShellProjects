#!/usr/bin/env bash
#cito M:755 O:0 G:0 T:/usr/bin/mkpass
#----------------------------------------------------------------------------------
# Project Name      - Extra/source/mkpass
# Started On        - Fri 20 Oct 12:14:09 BST 2017
# Last Change       - Sun 16 Feb 22:58:46 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

set -e
. /usr/lib/tflbp-sh/Err
set +e

CurVer='2020-02-16'
Progrm=${0##*/}

Usage(){
	while read; do
		printf "%s\n" "$REPLY"
	done <<-EOF
		            ${Progrm^^} ($CurVer)
		            Written by terminalforlife <terminalforlife@yahoo.com>

		            Pure Bourne Again Shell approach to complex password generation.

		SYNTAX:     $Progrm [OPTS] [INT]

		OPTS:       --help|-h|-?            - Display this help information.
		            --version|-v            - Output the version datestamp.
		            --type|-t TYPE          - Where TYPE is the type to use.

		TYPES:      Valid types below.

		              alnum, alpha, digit, punct, alnumpunct

		NOTE:       This small program uses '/dev/urandom' to generate a wide
		            range of characters, just as you would expect from
		            genpass, but fuller and with extra features and choices for
		            the user.

		            Where INT is the number of characters to generate.
	EOF
}

while [ "$1" ]; do
	case $1 in
		--help|-h|-\?)
			Usage; exit 0 ;;
		--version|-v)
			printf '%s\n' "$CurVer"; exit 0 ;;
		--type|-t)
			shift; Type=$1 ;;
		-*)
			Err 1 "Incorrect argument(s) specified." ;;
		*)
			break ;;
	esac
	shift
done

if [[ $1 =~ ^[0-9]+$ ]]; then
	Int=$1
elif [ -z "$Int" ]; then
	Err 1 'Invalid or missing INT.'
elif ! [ -e /dev/urandom ]; then
	Err 1 "Unable to access the '/dev/urandom' device."
elif ! [[ "$*" =~ [0-9]+ ]] && [ $Int -ge 1 ]; then
	Err 1 'Requires an integer >= 1.'
fi

case ${Type:-EMPTY} in
	punct)
		Chars='[\`/\+\\\|\_\,\.\?\!\"\\\/\$\%\^\&\*\(\)\{\}\]\[-\>\<\:\@\~]' ;;
	digit)
		Chars='[[:digit:]]' ;;
	alpha)
		Chars='[[:upper:][:lower:]]' ;;
	alnum)
		Chars='[[:upper:][:lower:][:digit:]]' ;;
	alphapunct|EMPTY)
		Chars='[\_\,\.\?\!\"\\\/\$\%\^\&\*\(\)\{\}\]\[-\>\<\:\@\~\`/\+\\\|[:upper:][:lower:][:digit:]]' ;;
	*)
		Err 1 'Invalid Type selected.' ;;
esac

declare -i A=0
while read -a X; do
	if [[ ${X:0:1} == $Chars ]]; then
		A+=1
		printf '%s' "${X:0:1}"
		[ $A -eq $Int ] && break
	fi
done < /dev/urandom

printf '\n'
