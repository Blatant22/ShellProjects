#!/usr/bin/env bash
#cito M:755 O:0 G:0 T:/usr/bin/snotes
#------------------------------------------------------------------------------
# Project Name      - Extra/source/snotes
# Started On        - Fri  9 Feb 00:07:19 GMT 2018
# Last Change       - Fri  3 Sep 00:29:03 BST 2021
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# Features:
#
# N/A
#
# Bugs:
#
#TODO: Fix clash between snotes' arguments and those found in the notes file.
#
#      Also, --edit/-e CMD is not working.
#
# To use your own comment character, change the Comment variable. This feature
# will eventually be included into snotes properly.
#------------------------------------------------------------------------------

CurVer='2021-09-03'
Progrm=${0##*/}

Comment='#'

Usage(){
	while read; do
		printf '%s\n' "$REPLY"
	done <<-EOF
		Usage: $Progrm [OPTS] [MATCH]

		  -h, --help               - Displays this help information.
		  -v, --version            - Output only the version datestamp.
		  -C, --comment [STR]      - Use STR as the single comment character.
		  -f, --file [PATH]        - Specify & remember the notes file to use.

		  By default, the notes file saved in the $Progrm configuration file
		  will be the one used.

		  Regular expressions are used for MATCH. Comment lines are ignored. To
		  tell $Progrm when you wish to stop searching for MATCH, have a line
		  in the notes file which contains only:

		    ${Comment}END

		  The default comment character is '$Comment'.

		  The use of '--' to ignore proceeding flags is supported.
	EOF
}

Err(){
	printf 'ERROR: %s\n' "$2" 1>&2
	(( $1 > 0 )) && exit $1
}

ProjConf="$HOME/.config/$Progrm.conf"

while [ -n "$1" ]; do
	case $1 in
		--)
			break ;;
		--help|-h|-\?)
			Usage; exit 0 ;;
		--version|-v)
			printf '%s\n' "$CurVer"; exit 0 ;;
		--comment|-C)
			shift; Comment=${1:0:1} ;;
		--file|-f)
			shift; NotesFile=$1 ;;
		-*)
			Err 1 'Incorrect argument(s) specified.' ;;
		*)
			break ;;
	esac
	shift
done

(( $# > 1 )) && Err 1 'Multiple matches are not supported.'

FileChk(){
	if ! [ -f "$NotesFile" ]; then
		Err 1 'File not found.'
	elif ! [ -r "$NotesFile" ]; then
		Err 1 'File unreadable.'
	fi
}

if [ -f "$ProjConf" ]; then
	if [ -n "$NotesFile" ]; then
		FileChk
		read -n 1 -ep 'Notes file already set -- replace? [Y/N] '
		case $REPLY in
			[Yy]|[Yy][Ee][Ss])
				if ! [ -d "$HOME/.config" ]; then
					if type -P mkdir > /dev/null 2>&1; then
						mkdir "$HOME/.config"
					else
						Err 1 "Dependency 'mkdir' not met."
					fi
				fi

				printf '%q\n' "$NotesFile" > "$ProjConf" ;;
			[Nn]|[Nn][Oo])
				printf 'No action taken -- quitting.\n'
				exit 0 ;;
		esac
	else
		NotesFile=$(< "$ProjConf")
	fi
else
	printf "$NotesFile\n" > "$ProjConf"
fi

FileChk
LineCount=0
LineCountLenMax=0
while read -r CurLine; do
	let LineCount++

	[ "$CurLine" == "${Comment}END" ] && break
	if [[ $CurLine =~ ^($|$Comment) ]]; then
		continue
	elif [[ $CurLine =~ $1 ]]; then
		LineCountLen=${#LineCount}
		if (( LineCountLen > LineCountLenMax )); then
			LineCountLenMax=$LineCountLen
		fi

		FinalLines+=("$LineCount:$CurLine")
	fi
done < "$NotesFile"

for Line in "${FinalLines[@]}"; {
	printf '\e[2;37m%*d\e[0m  %s\n'\
		$LineCountLenMax ${Line%%:*} "${Line#*:}"
}
