#!/usr/bin/env bash
#cito M:755 O:0 G:0 T:/usr/bin/snotes
#------------------------------------------------------------------------------
# Project Name      - Extra/source/snotes
# Started On        - Fri  9 Feb 00:07:19 GMT 2018
# Last Change       - Fri 19 May 17:59:50 BST 2023
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# With as old as BASH 3.1 support and POSIX-compliant mkdir(1) usage, this
# tool allows the user to view and filter notes. Snotes is intended for
# programmers, but can absolutely be used outside of that realm.
#
# Features:
#
#TODO: Find a way to incorporate a multi-character comment string.
#
#      Prior to a recent overhaul of Snotes, this was a given feature.
#      However, due to the sheer complexity and limitation of the new code put
#      in place, only one comment character is so far supported.
#
# Bugs:
#
# N/A
#
# Dependencies:
#
#   bash (>= 3.1)
#   coreutils (>= 8.28)
#------------------------------------------------------------------------------

CurVer='2023-05-19'
Progrm='snotes'

Usage() {
	read -d '' <<-EOF
		Usage: $Progrm [OPTS] [STRING]

		  -h, --help               - Displays this help information.
		  -v, --version            - Output only the version datestamp.
		  -C, --no-colors          - Disable ANSI color escape sequences.
		  -c, --comment CHAR       - Use CHAR as the single comment character.
		  -f, --file PATH          - Specify & remember the notes file to use.
		  -n, --line-number        - Print line numbers in grep(1) style.

		  The location of the file read by ${Progrm^} is saved here:

		    ${SnotesFile/$HOME/\~}

		  Comment lines are ignored. To tell $Progrm when you wish to stop
		  searching for STRING, add a line in the file containing only:

		    ${Comment}END

		  The default comment character is '$Comment'.

		  The use of '--' to ignore proceeding flags is supported. The use of
		  '-' to read from STDIN, instead of the assigned file, is also
		  supported.
	EOF

	printf '%s' "$REPLY"
}

Err() {
	printf 'Err: %s\n' "$2" 1>&2
	(( $1 > 0 )) && exit $1
}

BRed=$'\e[1;31m'
Green=$'\e[32m'
Cyan=$'\e[36m'
Reset=$'\e[0m'

NoColors=
ReadSTDIN=
Comment='#'
LineNumber=
SnotesFile="$HOME/.config/$Progrm.conf"

while [[ -n $1 ]]; do
	case $1 in
		--)
			shift
			break ;;
		-)
			ReadSTDIN='True' ;;
		--help|-h)
			Usage; exit 0 ;;
		--version|-v)
			printf '%s\n' "$CurVer"; exit 0 ;;
		-C|--no-colors|--no-colours)
			NoColors='True' ;;
		--comment|-c)
			ArgComment=$1
			if [[ -z $2 ]]; then
				Err 1 "Option '$ArgComment' requires an argument."
			elif (( ${#2} > 1 )); then
				Err 1 "Option '$ArgComment' only supports a single character."
			else
				Comment=$2
				shift
			fi ;;
		--file|-f)
			ArgFile=$1
			if [[ -z $2 ]]; then
				Err 1 "Option '$ArgFile' requires an argument."
			else
				NotesFile=$2
				shift
			fi ;;
		--line-number|-n)
			LineNumber='True' ;;
		-*)
			Err 1 'Incorrect argument(s) specified.' ;;
		*)
			break ;;
	esac
	shift
done

if ! type -P mkdir &> /dev/null; then
	Err 1 "Dependency 'mkdir' not met."
fi

(( $# > 1 )) && Err 1 'Multiple matches not supported.'

#---------------------------------------------Process or Create the Snotes File

if [[ -n $NotesFile ]]; then
	ConfigDir=${SnotesFile%/*}
	[[ -d $ConfigDir ]] || mkdir -p "$ConfigDir"
	printf '%s\n' "$NotesFile" > "$SnotesFile"

	printf 'NOTE: New location saved.\n'
	exit 0
fi

if [[ $ReadSTDIN == True ]]; then
	NotesFile='/dev/stdin'
else
	[[ -r $SnotesFile ]] || Err 1 "File '$SnotesFile' unreadable."
	NotesFile=$(< "$SnotesFile")

	if ! [[ -f $NotesFile ]]; then
		Err 1 'Notes file not found.'
	elif ! [[ -r $NotesFile ]]; then
		Err 1 'Notes file unreadable.'
	fi
fi

#----------------------------------------------------------------Main Functions

# Usage: PrintLine LINE_NUMBER LINE_DATA
PrintLine() {
	if [[ $LineNumber == True ]]; then
		local NumberOut="$Green$1$Reset$Cyan:$Reset"
	fi

	printf '%s%s\n' "$NumberOut" "$2"
}

#--------------------------------------------------------Parse and Display Data

# Also allow removing colors when non-interactive (e.g., pipe).
if [[ $NoColors == True || ! -t 1 ]]; then
	BRed=
	Green=
	Cyan=
	Reset=
fi

Match=$1
MatchLen=${#Match}

Found=
LineNr=0
while read -r; do
	(( LineNr++ ))

	# Ignore standard comment lines and stop at '#END' line.
	if [[ $REPLY == "${Comment}END" ]]; then
		break
	elif [[ ${REPLY:0:1} == "$Comment" ]]; then
		continue
	fi

	if (( $# == 0 )) && [[ -n $REPLY && $REPLY != +([[:space:]]) ]]; then
		PrintLine $LineNr "$REPLY"

		continue
	fi

	MIndex=0
	LineOut=
	CurMatchRaw=
	Len=${#REPLY}
	for (( LIndex = 0; LIndex < Len; LIndex++ )); {
		if [[ ${REPLY:LIndex:1} == "${Match:MIndex:1}" ]]; then
			CurMatchRaw+=${REPLY:LIndex:1}

			(( MIndex++ ))

			if [[ $CurMatchRaw == "$Match" ]]; then
				LineOut+="$BRed$CurMatchRaw$Reset"

				# To help us print only lines with matches.
				Found='True'
			fi

			# Very confusing, but required. If the first character of the
			# target match is the last character of the line, the last
			# character will be omitted from the final output. This addresses
			# that.
			#
			# The alternative is to arbitrarily increase the length of the line
			# by 1, but I'd be concerned of unexpected and undesired results.
			if (( LIndex == Len - 1 )); then
				if [[ ${REPLY:Len - 1:1} == "${Match:0:1}" ]]; then
					LineOut+=${REPLY:LIndex:1}

					break
				fi
			fi
		else
			# If found the first or last character of the match, but there's an
			# incomplete match, then still send those characters to be printed.
			if [[ -n $CurMatchRaw ]]; then
				if [[ ${CurMatchRaw:-1:1} != ${Match:-1:1} ]]; then
					LineOut+=${REPLY:LIndex - 1:1}
				fi
			fi

			# Catch 'command not found' errors in < BASH 3.1.
			LineOut+=${REPLY:LIndex:1} || exit $?

			CurMatchRaw=
			MIndex=0
		fi
	}

	# Begin printing, if 1 or more matches were found on this line.
	if [[ $Found == True ]]; then
		PrintLine $LineNr "$LineOut"

		Found=
	fi
done < "$NotesFile"
