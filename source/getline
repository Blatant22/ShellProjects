#!/usr/bin/env bash
#cito M:755 O:0 G:0 T:/usr/bin/getline
#----------------------------------------------------------------------------------
# Project Name      - Extra/source/getline
# Started On        - Tue 19 Sep 20:57:01 BST 2017
# Last Change       - Sat 22 Feb 17:01:04 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# Features:
#
#TODO: Add ranges to 'line' action, like: line 2-50,57-59,70-74
#TODO: Finish 'start' action.
#TODO: Finish end action.
#TODO: Finish summary. Target: show sum of concatenated 'count' results.
#TODO: Improve performance of 'count' actions.
#
# Bugs:
#
#TODO: Does 'for CHAR in' line include spaces and/or tabs? Find out.
#TODO: Why won't 'line' action display >1 line at a time?
#
# Dependencies:
#
#   bash (>= 4.3-14)
#   libtflbp-sh (>= 2019-12-10)
#----------------------------------------------------------------------------------

set -e
. /usr/lib/tflbp-sh/Err
set +e

CurVer='2020-02-22'
Progrm=${0##*/}

Usage(){
	while read; do
		printf "%s\n" "$REPLY"
	done <<-EOF
		            ${Progrm^^} ($CurVer)
		            Written by terminalforlife <terminalforlife@yahoo.com>

		            Pure Bourne Again Shell way to handle a plain text file.

		SYNTAX:     $Progrm [OPTS] [ACTION] [FILE_1 [FILE_2] ...]

		OPTS:       --help|-h|-?            - Display this help information.
		            --version|-v            - Output the version datestamp.
		            --debug|-D              - Enable built-in bash debugging.
		            --names|-N              - Show filenames with results.
		            --nocolor|-c            - Disable almost all color.
		            --nums|-n               - Line numbers when viewing files.
		            --sum|-S                - Display total with 'count'.
		            --ttl|-t                - Lotal numbers, without filename.

		ACTIONS:    ccount                  - Count number of chars in FILE.
		            end N                   - Show last N number of lines.
		            field L:F               - Show only F field on L line.
		            gmatch GLOB             - Extended glob matching via GLOB.
		            lcount                  - Count number of lines in FILE.
		            line N[,N ...]          - Display Nth line(s) in FILE.
		            read                    - Output all contents of FILE.
		            read:N                  - Auto-scroll N number of seconds.
		            rmatch REGEX            - Grep-like REGEX matching.
		            start N                 - Show first N number of lines.
		            wcount                  - Count number of words in FILE.

		NOTE:       Words, lines, and chars are determined in a shell-like way.

		EXAMPLE:    $Progrm field 14:2 /etc/bash.bashrc
		            $Progrm --nums read ~/.bashrc
		            $Progrm --ttl lcount /etc/fstab
		            $Progrm -c gmatch "kernel:" /var/log/syslog
		            $Progrm read /etc/passwd
	EOF
}

declare -i ACTION_COUNT=0
SHOW_NAMES='false'
TOTAL_ONLY='false'
LINE_NUMBERS='false'
COLOR_MODE='true'

while [ "$1" ]; do
	case $1 in
		--help|-h|-\?)
			Usage; exit 0 ;;
		--version|-v)
			printf "%s\n" "$CurVer"
			exit 0 ;;
		--debug|-D)
			DebugMe='true' ;;
		--nums|-n)
			LINE_NUMBERS='true' ;;
		--ttl|-t)
			TOTAL_ONLY='true' ;;
		--nocolor|-c)
			COLOR_MODE='false' ;;
		--names|-N)
			SHOW_NAMES='true' ;;
		--sum|-S)
			Err 1 'Feature not yet available.'
			SHOW_SUM='true' ;;
		-*)
			Err 1 'Unrecognised option(s) specified.' ;;
		*)
			break ;;
	esac
	shift
done

while [ "$1" ]; do
	case $1 in
		read)
			ACTION_COUNT+=1
			INSTRUCT="read" ;;
		read:[1-9])
			ACTION_COUNT+=1
			INSTRUCT="read:${1/*:}" ;;
		start)
			Err 1 'Feature not yet available.'

			shift

			ACTION_COUNT+=1
			INSTRUCT="start"
			STARTNUM=$1

			if [[ $STARTNUM =~ [0-9]+ ]]; then
				Err 1 'Incorrect start number chosen.'
			fi ;;
		end)
			Err 1 'Feature not yet available.'

			shift

			ACTION_COUNT+=1
			INSTRUCT="end"
			ENDNUM=$1

			if ! [[ $ENDNUM =~ ^[0-9]+$ ]]; then
				Err 1 'Incorrect end number chosen.'
			fi ;;
		line)
			shift

			ACTION_COUNT+=1
			INSTRUCT="showline"

			for L in ${1//,/ }; {
				if ! [[ $L =~ ^[0-9]+$ ]]; then
					Err 1 "Incorrect line number: $L"
				fi

				# This is to ensure the user doesn't get confused
				# when they enter line 1, expecting line 1 as per
				# wc, yet see line 2, because arrays start at 0.
				let L--

				LINETOSHOW+=" $L"
			} ;;
		field)
			shift

			ACTION_COUNT+=1
			INSTRUCT='showfield'
			CUTLINE=$1

			if ! [[ $CUTLINE =~ [0-9]+:[0-9]+ ]]; then
				Err 1 'Incorrect cut line/field selected'
			fi ;;
		lcount)
			ACTION_COUNT+=1
			INSTRUCT='lcount' ;;
		wcount)
			ACTION_COUNT+=1
			INSTRUCT='wcount' ;;
		ccount)
			ACTION_COUNT+=1
			INSTRUCT='ccount' ;;
		gmatch)
			shift
			ACTION_COUNT+=1
			INSTRUCT="gmatch=$1" ;;
		rmatch)
			shift
			ACTION_COUNT+=1
			INSTRUCT="rmatch=$1" ;;
		*)
			break ;;
	esac

	shift
done

if [ "$COLOR_MODE" == 'true' ]; then
	GREY='\e[1;30m'
	NORMAL='\e[0m'
fi

if [ $ACTION_COUNT -gt 1 ]; then
	Err 1 'Only one action at a time may be specified.'
fi

[ "$DebugMe" == 'true' ] && set -x

if ! [ "$INSTRUCT" ]; then
	Err 1 'Unrecognised or missing action(s).'
else
	[ "$*" ] && FILELIST+="$@ "
fi

if [ "$INSTRUCT" == 'showfield' ]; then
	# As above, but with the f part in action show-field=l:f.
	CUTFIELD=${CUTLINE/*:}
	let CUTFIELD--

	[ $CUTFIELD -lt 0 ] && Err 1 'Incorrect field selected.'
fi

if ! [[ $INSTRUCT == [wlc]count ]] && [ "$TOTAL_ONLY" == 'true'  ]; then
	Err 1 "Option '--ttl|-t' requires a paired option."
fi

# This function saves repetition when a line or lines need to be displayed. Use
# $1 for the variable which contains the line number, $2 for the actual file's
# data, and use $3 for the newline \n character, if desired.
LINE_NUM_FUNC(){
	if [ "$LINE_NUMBERS" == 'false' ]; then
		printf "%s$3" "$2"
	else
		[ "$2" ] || continue
		printf "${GREY}%#6d$NORMAL  %s$3" "$1" "$2"
	fi
}

for FILE in $FILELIST; {
	# Initialize the variables used in this for loop. This is to ensure when
	# working with a new file in FILELIST, the variables don't carry over.
	CHARCOUNT=0; LINECOUNT=0; WORDCOUNT=0; GETWORDS=

	if ! [[ $INSTRUCT == [wlc]count ]] && [ "$SHOW_NAMES" == 'true' ]; then
		printf "FILE: %s\n" "$FILE"
	fi

	if ! [ "$FILE" ]; then
		Err 1 "No filename(s) specified."
	elif ! [ -f "$FILE" -a -r "$FILE" ]; then
		Err 1 "File missing or inaccessible: $FILE"
	fi

	if [ "$INSTRUCT" == 'showline' ]; then
		readarray REPLY < "$FILE"
		for L in $LINETOSHOW; {
			LINE_NUM_FUNC "$LINETOSHOW" "${REPLY[$L]}"
		}

		continue
	fi

	# For the current file, read each line and process it as follows. Needed to
	# use -r and IFS= to avoid formatting issues with the output.
	while IFS= read -r REPLY; do
		# Remove newline characters from the current line. This fixes the
		# issue whereby using \ in files (particularly code) to continue
		# a long command on the next line, would not display correctly.
		REPLY=${REPLY//}

		# Fixes issue whereby empty lines were being ignored. This converts
		# empty lines to a literal new line character. (\n doesn't work)
		[ -z "$REPLY" ] && REPLY+=""

		# Replace each character in the current line with a + followed by
		# a space, thus allowing the for loop to recognise each field and
		# so able to count each one, using let's increment.
		for CHAR in ${REPLY//?/+ }; { let CHARCOUNT++; }

		# Continue to the next line, ignoring what's left of the while loop
		# if all you want is the character count. Saves unnecessary
		# processing and likely conflicts.
		[ "$INSTRUCT" == "ccount" ] && continue

		let LINECOUNT++

		if [ "$INSTRUCT" == "showfield" ]; then
			# Check if on the right line for show-field.
			if [ ${CUTLINE%:*} -eq $LINECOUNT ]; then
				read -a ARRAY <<< "$REPLY"
				printf "%s\n" "${ARRAY[$CUTFIELD]}"
				break
			fi
		fi

		# Process the results of each action listed here.
		case $INSTRUCT in
			read)
				# Output the file, like cat.
				LINE_NUM_FUNC "$LINECOUNT" "$REPLY" "\\n" ;;
			read:[1-9])
				# Output the file, like cat, but autoscroll.
				LINE_NUM_FUNC "$LINECOUNT" "$REPLY" "\\n"

				# Sleep for n number of seconds before scrolling.
				sleep ${INSTRUCT/*:}s ;;
			gmatch=*)
				# If the current line contains the match given by
				# the user and stored in INSTRUCT=*. Uses globbing.
				if [[ $REPLY == *${INSTRUCT/*=}* ]]; then
					LINE_NUM_FUNC "$LINECOUNT" "$REPLY" "\\n"
				fi ;;
			rmatch=*)
				# As gmatch, but uses extended regex.
				if [[ $REPLY =~ ${INSTRUCT/*=} ]]; then
					LINE_NUM_FUNC "$LINECOUNT" "$REPLY" "\\n"
				fi ;;
		esac
	done < "$FILE"

	# Saves repetition by calling this function for each following INSTRUCT.
	# Supply the first positional parameter with the variable from which to get
	# the total. Easier to add to.
	TTL_OUTPUT(){
		if ! [ "$TOTAL_ONLY" == 'true' ]; then
			printf "%s %s\n" "$1" "$FILE"
		else
			printf "%s\n" "$1"
		fi
	}

	# Process the results of each action listed here.
	case $INSTRUCT in
		lcount)
			# Display total number of lines.
			TTL_OUTPUT "$LINECOUNT" ;;
		wcount)
			# Display total number of words.
			GETWORDS=$(for I in `< "$FILE"`; { printf "%s\n" "$I"; })
			for WORD in $GETWORDS; { let WORDCOUNT++; }
			TTL_OUTPUT "$WORDCOUNT" ;;
		ccount)
			# Display total number of characters.
			TTL_OUTPUT "$CHARCOUNT" ;;
	esac

	if [ "$SHOW_SUM" == 'true' ]; then
		:
	fi
}
