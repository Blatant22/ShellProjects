#!/usr/bin/env bash

#------------------------------------------------------------------------------
# Project Name      - Extra/source/trybash
# Started On        - Mon  6 Dec 00:18:01 GMT 2021
# Last Change       - Mon 20 Dec 14:51:00 GMT 2021
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# I'm usually on BASH 4.4 or whatever is available in my current Ubuntu-based
# installation of Linux. This means that I lose out on newer features of BASH.
#
# In order to both test my BASH programs in newer versions of BASH, and to just
# explore new features and to test any old code which might now be broken, I
# wrote this script.
#
# In a nut-shell, this allows you to quickly get up and running in a BASH
# version (regular) of your choice.
#
# WARNING: This script does NOT (yet?) verify the signature of the tarball.
#------------------------------------------------------------------------------

URL='https://mirror.lyrahosting.com/gnu/bash'

# Setting this to 'True' will tell this script not to remove the downloaded
# tarball or the extracted, configured, and compiled contents.
NoCleanUp='True'

# Setting this to 'True' will tell the new BASH instance to ignore most of your
# BASH configurations, like '~/.bashrc'. This actually uses the `--norc` flag
# with BASH, but I cannot guarantee all versions will support this flag or work
# in the same way.
NoConfig='False'

Err(){
	printf '\e[91mErr\e[0m: %s\n' "$2" 1>&2
	[ $1 -gt 0 ] && exit $1
}

(( $# > 0 )) && Err 1 'This script takes no arguments.'

#-----------------------------------------------Determining Number of CPU Cores

ProcInfoFile='/proc/cpuinfo'
if [ -f "$ProcInfoFile" -a -r "$ProcInfoFile" ]; then
	while read -a Line; do
		if [ "${Line[0]}${Line[1]}" == 'cpucores' ]; then
			TTLCores=${Line[3]}
			break
		fi
	done < "$ProcInfoFile"
else
	TTLCores=`nproc`
fi

unset ProcInfoFile

Cores=$TTLCores

[[ $TTLCores =~ ^[[:digit:]]+$ ]] || Cores=1

printf 'Using %d/%d available CPU core(s).\n' $Cores $TTLCores

#------------------------------------------Generate List of Valid BASH Tarballs

while read; do
	[[ $REPLY =~ ^.*'>'(.*)'</a>'.*$ ]] || continue

	# Need this, because it gets scrapped when you use `=~` again, even if you
	# don't reuse the same captured group number.
	File=${BASH_REMATCH[1]}

	[[ $File =~ ^bash-[[:digit:]]+\.[[:digit:]]+\.tar\.gz$ ]] && Files+=("$File")
done <<< "$(wget -qO - "$URL")"

# Re-order the old-to-new sorted list of files to new-to-old.
TotalFiles=${#Files[@]}
for (( Start = TotalFiles - 1; Start >= 0; Start-- )); {
	SortedFiles+=("${Files[Start]}")
}

unset Files

#--------------------------------------------Get Target Tarball from User Input

printf 'Please \e[93mselect\e[0m a tarball of BASH to use.\n\n'

Count=1
for File in "${SortedFiles[@]}"; {
	(( Count > 10 )) && break

	printf '  %4s  %s\n' "($Count)" "$File"
	(( Count++ ))
}

unset Count File

printf '\n'

while :; do
	read -p '> ' GetVersion

	if [ -z "$GetVersion" ]; then
		Err 0 'Null response.'
		continue
	elif ! [[ $GetVersion =~ ^([123456789]|10)+$ ]]; then
		Err 0 'Invalid response.'
		continue
	fi

	ChosenFile=${SortedFiles[GetVersion - 1]}
	ChosenVersion=${ChosenFile#*-}
	ChosenVersion=${ChosenVersion%.tar.gz}
	printf 'You selected \e[92mBASH %s\e[0m -- continue?\n' "$ChosenVersion"
	while :; do
		read -p '> ' Confirm

		case $Confirm in
			[Yy]|[Yy][Ee][Ss])
				Happy='True'
				break ;;
			[Nn]|[Nn][Oo])
				Happy='False'
				break ;;
			'')
				Err 0 'Null response.' ;;
			*)
				Err 0 'Invalid response.' ;;
		esac
	done

	[ "$Happy" == 'True' ] && break
done

unset SortedFiles Happy GetVersion Confirm REPLY

#--------------------------Configure, Compile, then Run the Chosen BASH Version

wget -q --show-progress "$URL/$ChosenFile"
if tar -xzvf "$ChosenFile"; then
	[ "$NoCleanUp" == 'True' ] || rm -v "$ChosenFile"
fi

(
	set -e

	cd "${ChosenFile%.tar.gz}"
	./configure
	make -j $Cores

	# Enter `exit` from the new BASH instance to return to your usual shell, -
	# but not before removing the newly-installed version.
	case $NoConfig in
		'True')
			./bash --norc ;;
		'False')
			./bash ;;
	esac

	if ! [ "$NoCleanUp" == 'True' ]; then
		cd ..
		rm -vrf "${ChosenFile%.tar.gz}"
	fi
)

printf 'Done!\n'
