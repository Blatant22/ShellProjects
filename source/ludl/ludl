#!/usr/bin/env bash
#cito M:755 O:0 G:0 T:/usr/bin/ludl
#------------------------------------------------------------------------------
# Project Name      - Extra/source/ludl/ludl
# Started On        - Tue 11 Jan 22:43:03 GMT 2022
# Last Change       - Wed 12 Jan 02:11:25 GMT 2022
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# Tool to make it easy to download Linux Unplugged podcasts from the terminal.
# A caching system is provided, to reduce server load.
#
# You can choose to only show the direct download links, or you can immediately
# begin downloading the podcasts. You can specifically download the latest
# podcast, another specific podcast, or focus on a given range of podcasts.
#
# Features:
#
#TODO: Pad podcast numbers by 0, for more practical sorting.
#
#      This, and people's files, will need updating if they make one > 999.
#      Not entirely sure if this would be worth it.
#
#TODO: Be more verbose. Damn-near impossible to know what's happening!
#TODO: Consider a database system, in which is stored all podcast information.
#
#      This could be awesome. The database could have the number, run time, -
#      direct download link, and date. Then LUDL would just parse that, -
#      reducing server load and making things snappier. It'd still need to be
#      updated, but there might be a way to do all that well.
#
#TODO: Support cURL, too.
#TODO: Compress (GZip) the cache to save some MBs.
#TODO: Improve the podcast selection to be more like WCDL.
#TODO: Show more information, like podcast length and date.
#TODO: Add ability to choose a different target directory.
#TODO: Move cache to '~/.cache/ludl'.
#
# Bugs:
#
#TODO: Because of the associate array, podcasts are in random order.
#
#      This can be easily fixed, as I've done in CSi3. For now, use `-s` and
#      `-e` to specify single podcasts, or download at random until they're all
#      acquired.
#
# Dependencies:
#
#   bash (>= 4.0)
#   wget (>= 1.19.4-1)
#------------------------------------------------------------------------------

CurVer='2022-01-12'
Progrm=${0##*/}

Usage() {
	while read; do
		printf '%s\n' "$REPLY"
	done <<-EOF
		Usage: $Progrm [OPTS]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  -O, --links-only         - Output only the download links.
		  -e, --start [INT]        - Target from INT podcast.
		  -k, --kind               - Random wait time between each download.
		  -l, --latest             - Target only the latest podcast.
		  -s, --end [INT]          - Target up to INT podcast.

		  Downloaded podcasts are sent to the CWD.
	EOF
}

Err() {
	printf 'Err: %s\n' "$2" 1>&2
	(( $1 > 0 )) && exit $1
}

URL_Homepage='https://linuxunplugged.com'
MainDir="$HOME/.config/ludl"
CacheDir="$MainDir/cache"

while [[ -n $1 ]]; do
	case $1 in
		--help|-h|-\?)
			Usage; exit 0 ;;
		--version|-v)
			printf '%s\n' "$CurVer"; exit 0 ;;
		--links-only|-O)
			LinksOnly='True' ;;
		--start|-s)
			if [[ -z $2 ]]; then
				Err 1 "Option '$1' requires an argument."
			elif ! [[ $2 =~ ^[[:digit:]]+$ ]]; then
				Err 1 "Option '$1' requires an integer >= 1."
			else
				StartPoint=$2
				shift
			fi ;;
		--kind|-k)
			BeKind='True' ;;
		--latest|-l)
			Latest='True' ;;
		--end|-e)
			if [[ -z $2 ]]; then
				Err 1 "Option '$1' requires an argument."
			elif ! [[ $2 =~ ^[[:digit:]]+$ ]]; then
				Err 1 "Option '$1' requires an integer >= 1."
			else
				EndPoint=$2
				shift
			fi ;;
		*)
			Err 1 'Incorrect option(s) specified.' ;;
	esac
	shift
done

[[ -z $StartPoint ]] && StartPoint=1

DepCount=0
for Dep in wget mkdir; do
	if ! type -P "$Dep" &> /dev/null; then
		Err 0 "Dependency '$Dep' not met."
		(( DepCount++ ))
	fi
done

(( DepCount > 0 )) && exit 1

[[ -d $CacheDir ]] || mkdir -p "$CacheDir"

#----------------------------------------------Determine Current Podcast Number

if [[ -z $EndPoint || $Latest == True ]]; then
	while read; do
		if [[ $REPLY =~ \<a\ href=\"/([[:digit:]]+)\"\>\<figure\ id= ]]; then
			EndPoint=${BASH_REMATCH[1]}
			FoundMax='True'
			break
		fi
	done <<< "$(wget -U 'Mozilla/5.0' -qO - "$URL_Homepage")"
	[[ $FoundMax == True ]] || Err 1 'Unable to determine podcast count.'
fi

#--------------------------Gather the Podcast and Their URLs (Oldest-to-Newest)

[[ $Latest == True ]] && StartPoint=$EndPoint
for (( Pod = StartPoint; Pod <= EndPoint; Pod++ )); {
	if [[ -f $CacheDir/$Pod ]]; then
		Data=$(< "$CacheDir/$Pod")
	else
		Data=$(wget -U 'Mozilla/5.0' -qO - "$URL_Homepage/$Pod")
		printf '%s\n' "$Data" > "$CacheDir/$Pod"
	fi

	while IFS='"' read -a Line; do
		if [[ ${Line[3]} == $URL_Download*.mp3 ]]; then
			declare -A Pods[$Pod]=${Line[3]}
			break
		fi
	done <<< "$Data"

	if [[ -z ${Pods[$Pod]} ]]; then
		Err 1 "Failed to fetch #$Pod podcast-- quitting."
	fi
}

#----------------------------------------------------Start Downloading Podcasts

for Pod in "${!Pods[@]}"; {
	if [[ $LinksOnly == True ]]; then
		printf 'LU%d=%s\n' $Pod "${Pods[$Pod]}"
		continue
	fi

	wget -qcU 'Mozilla/5.0' --show-progress -O "lu$Pod.mp3" "${Pods[$Pod]}"

	if [[ $BeKind == True ]]; then
		read -n 1 -st $(( RANDOM % 10))
	fi
}
